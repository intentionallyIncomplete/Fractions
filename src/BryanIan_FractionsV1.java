import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * 
 * @author Ian Bryan
 *
 * Can you complete this without using arrays? What is the least number of variables you can use to solve this problem?
 * 
 * No, because we are using the split method or using the StringTokenizer methods, an array will be made. 
 * StringTokenizer and split will generate the need for an array.
 * 
 * Can you use just one array to solve this? What would the data type be of that array?
 * 
 * Yes, a multidimensional array could work. You will need 3 nested loops to go over first the rows,
 * then the columns, then the fraction in that space. Then you could operate on the fraction in that array index.
 * 
 * Can you nest* one class (data type) within another, 
 * like we observe with nested loops? What is an example of this? (*compose)
 * 
 * Yes, you may nest a "child" class inside a "parent" class. This increases encapsulation and maintains relevance and function
 * of utility methods to the class they apply to. A more visual representation of the programs usage and output
 * is provided when you nest a class that contains only functions relevant to the parent class it's nested in. 
 * 
 * What are some solutions to the reduction problem other than Euclid's GCD 
 * (greatest common divisor) algorithm? (You may want to look up GCD online.)
 * 
 * The only other possible way to determine two fractions are equal, that I can think of, is the rule of 
 * cross-multiplication. 
 * 
 * 
 *~~~~DESCRIPTION AND FUNCTIONALITY~~~~~
 * This program is designed to take in a file specified by file name and extension.
 * The contents of the file are read over as Strings and sent to an array.
 * The array of fractions (listOfFractions) is split using the split() method.
 * The split() method generates the need to an array of three elements (<lhs><op><rhs>)
 * The first index generated by the split() method is the <lhs> (left hand side) of the operator.
 * The first index generated by the split() method takes the i'th position in theNumerators[].
 * The second index generated by the split() method is the <rhs> (right hand side) of the operator.
 * The second index generated by the split() method takes the i'th position in theDenoms[].
 * Two temporary variables checkNumerator and checkDenom
 * take the value of the i'th element of the numerator and denominator arrays
 * A nested for loop checks 3 things:
 * 1) Boolean array fractionIndexed (all elements start as 'false') is queried for if not true. 
 * When queried, boolean is true and thus the index value is changed to true. When all numerators and denominators are checked,
 * all indices will be true, and the loop will stop. 
 * 2) checkNumerator (a local variable) is assigned the i'th index of theNumerators[]
 * then it is compared against all indices of theNumerators[].
 * The same is done for checkDenom with theDenoms[].
 * 3) The above conditions will generate a +1 increment in dupeCounter (a counter for duplicate fractions meaning that
 * the numerator and denominator of the arrays matched at least one numerator and denominator at the same time
 * in their respective array indices. 
 * For any fraction with no matching numerator/denominator sequence produces a +1 counter for dupeCounter.
 * The dupeCounter is set to 0 at the end of the first for-loop (the outside one)
 * 
 * ~~~~COMMENT~~~~~
 * I tried to set the size of the listOfFractions to the lineCounter using the following code:
 * 
 * I found this on StackOverflow and read more on what constitutes a "new line" 
 * and this did end up producing the correct line number
 * but when I compiled the code and ran it, it produced 31 "nulls". 
 * 
 *  public void openTheFile(){
 * 		BufferedReader readFile = new BufferedReader(new FileReader("fractions.txt"));
 *  	int numOfFracts = 0;
 *		while (readFile.readLine() != null) {numOfFracts++;}
 *		readFile.close();
 *
 *		Scanner dataFile = new Scanner("fractions.txt");
 *		String[] listOfFractions = new String[numOfFracts];
 *		while(dataFile.hasNextLine()){
 *			listOfFractions[i] = dataFile.nextLine();
 *		}
 *	}
 */

public class BryanIan_FractionsV1 {

	String[] listOfFractions = new String[31];
	private String[] splitFractions = new String[2];
	private int[] theNumerators = new int[31];
	private int[] theDenoms = new int[31];
	private boolean[] fractionIndexed = new boolean[31];

	private int lineCounter = 0;
	private int dupeCounter = 0;
	private int checkDenom = 0;
	private int checkNumerator = 0;

	Scanner dataFile = null;

	public static void main(String[] args) {

		BryanIan_FractionsV1 fv1 = new BryanIan_FractionsV1();
		fv1.openTheFile();
		fv1.countRowsInFile();
		fv1.splitListOfFractions();
		fv1.compareND();
		fv1.closeTheFile();
	}

	public void openTheFile(){

		try{
			dataFile = new Scanner(new File("fractions.txt"));
		}catch(FileNotFoundException e){
			System.out.println("Program unable to locate file. Check directory and try again");
			System.exit(0);
		}
	}
	
	public void countRowsInFile(){

		for(int a=0;dataFile.hasNextLine();a++){
			listOfFractions[a] = dataFile.nextLine();
			lineCounter++;
		}
	}

	public void splitListOfFractions(){
		for(int b=0;b<lineCounter;b++){
			splitFractions = listOfFractions[b].split("/");
			theNumerators[b] = Integer.parseInt(splitFractions[0]);
			theDenoms[b] = Integer.parseInt(splitFractions[1]);
		}
	}
	public void compareND(){

		for(int i=0;i<lineCounter;i++){
			checkNumerator = theNumerators[i];
			checkDenom = theDenoms[i];

			//nested for-loop
			for(int c=0;c<lineCounter;c++){
				if(!fractionIndexed[c]){
					if(checkDenom == theDenoms[c]){
						if(checkNumerator == theNumerators[c]){
							dupeCounter++;
							fractionIndexed[c] = true; //the fraction already exists in the listOfFractions array
						}//end if block
					}//end if block
				}//end last nested if
			}//end for loop

			if(dupeCounter > 0){
				System.out.println(checkNumerator + "/" + checkDenom + " has a count of " + dupeCounter);
			}
			dupeCounter = 0;
		}
	}

	//close the file for the end of the program
	public void closeTheFile(){dataFile.close();
	}
}